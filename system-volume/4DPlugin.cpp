/* --------------------------------------------------------------------------------
 #
 #	4DPlugin.cpp
 #	source generated by 4D Plugin Wizard
 #	Project : system-volume
 #	author : miyako
 #	2015/07/08
 #
 # --------------------------------------------------------------------------------*/


#include "4DPluginAPI.h"
#include "4DPlugin.h"

#if VERSIONMAC
//https://github.com/InerziaSoft/ISSoundAdditions/blob/master/ISSoundAdditions.m
AudioDeviceID obtainDefaultOutputDevice()
{
    AudioDeviceID theAnswer = kAudioObjectUnknown;
    UInt32 theSize = sizeof(AudioDeviceID);
    AudioObjectPropertyAddress theAddress;
	
	theAddress.mSelector = kAudioHardwarePropertyDefaultOutputDevice;
	theAddress.mScope = kAudioObjectPropertyScopeGlobal;
	theAddress.mElement = kAudioObjectPropertyElementMaster;
	
	//first be sure that a default device exists
	if(!AudioObjectHasProperty(kAudioObjectSystemObject, &theAddress)){
		NSLog(@"Unable to get default audio device");
		return theAnswer;
	}
	//get the property 'default output device'
    OSStatus theError = AudioObjectGetPropertyData(kAudioObjectSystemObject, &theAddress, 0, NULL, &theSize, &theAnswer);
    if(theError != noErr){
		NSLog(@"Unable to get output audio device");
		return theAnswer;
	}
    return theAnswer;
}
#else
const CLSID CLSID_MMDeviceEnumerator = __uuidof(MMDeviceEnumerator);
const IID IID_IMMDeviceEnumerator = __uuidof(IMMDeviceEnumerator);
const IID iidAEV = __uuidof(IAudioEndpointVolume);
#endif

void PluginMain(PA_long32 selector, PA_PluginParameters params)
{
	try
	{
		PA_long32 pProcNum = selector;
		sLONG_PTR *pResult = (sLONG_PTR *)params->fResult;
		PackagePtr pParams = (PackagePtr)params->fParameters;

		CommandDispatcher(pProcNum, pResult, pParams); 
	}
	catch(...)
	{

	}
}

void CommandDispatcher (PA_long32 pProcNum, sLONG_PTR *pResult, PackagePtr pParams)
{
	switch(pProcNum)
	{
// --- System Volume

		case 1 :
			AUDIO_SET_VOLUME(pResult, pParams);
			break;

		case 2 :
			AUDIO_Get_volume(pResult, pParams);
			break;

		case 3 :
			AUDIO_SET_MUTE(pResult, pParams);
			break;

		case 4 :
			AUDIO_Get_mute(pResult, pParams);
			break;

	}
}

// --------------------------------- System Volume --------------------------------

void AUDIO_SET_VOLUME(sLONG_PTR *pResult, PackagePtr pParams)
{
	C_REAL Param1;
    
	Param1.fromParamAtIndex(pParams, 1);

#if VERSIONMAC	
	float						newValue = Param1.getDoubleValue();
	AudioObjectPropertyAddress	theAddress;
	AudioDeviceID				defaultDevID;
	OSStatus					theError = noErr;
	Boolean						canSetVol = YES;
        
    newValue = newValue > 1.0 ? 1.0 : (newValue < 0.0 ? 0.0 : newValue);       

    if((newValue < THRESHOLD)){
        AUDIO_SET_MUTE(0);
    }else{
    
        defaultDevID = obtainDefaultOutputDevice();
        
        if(defaultDevID != kAudioObjectUnknown){
        
            theAddress.mElement = kAudioObjectPropertyElementMaster;
            theAddress.mScope = kAudioDevicePropertyScopeOutput;
            theAddress.mSelector = kAudioHardwareServiceDeviceProperty_VirtualMasterVolume;
            
            if(AudioObjectHasProperty(defaultDevID, &theAddress)){
            
                theError = AudioObjectIsPropertySettable(defaultDevID, &theAddress, &canSetVol);
                
                if(theError == noErr && canSetVol){
                
                    AudioObjectSetPropertyData(defaultDevID, &theAddress, 0, NULL, sizeof(newValue), &newValue);

                }
            }
        }
    }
#else    

    HRESULT hr;
    IMMDeviceEnumerator *pDevEnum;
    IMMDevice *pDev;
    IAudioEndpointVolume *pIaudEndPt;
    DWORD dwClsCtx = 0;
    float fVolume = (float)Param1.getDoubleValue();
    
    fVolume = fVolume > 1.0 ? (float)1.0 : (float)(fVolume < 0.0 ? 0.0 : fVolume); 
    
    if((fVolume < THRESHOLD)){
        AUDIO_SET_MUTE(FALSE);
    }else{ 
        
        hr = CoCreateInstance(CLSID_MMDeviceEnumerator, NULL, CLSCTX_ALL, IID_IMMDeviceEnumerator, (void**)&pDevEnum);

        if(hr == S_OK){
            hr = pDevEnum->GetDefaultAudioEndpoint(eRender, eConsole, &pDev);
            if(hr == S_OK){
                hr = pDev->Activate(iidAEV, dwClsCtx, NULL, (void**) &pIaudEndPt);
                if(hr == S_OK){
                    hr = pIaudEndPt->SetMasterVolumeLevelScalar(fVolume, NULL);
                }
                pDev->Release();
            }  
            pDevEnum->Release(); 
        }     
        
    }
#endif    
}

void AUDIO_Get_volume(sLONG_PTR *pResult, PackagePtr pParams)
{
	C_REAL returnValue;

#if VERSIONMAC	
    AudioDeviceID				defaultDevID = kAudioObjectUnknown;
	UInt32						theSize = sizeof(Float32);
	OSStatus					theError;
	Float32						theVolume = 0;
	AudioObjectPropertyAddress	theAddress;
    
    defaultDevID = obtainDefaultOutputDevice();
    
	if(defaultDevID != kAudioObjectUnknown){

        theAddress.mElement = kAudioObjectPropertyElementMaster;    
        theAddress.mScope = kAudioDevicePropertyScopeOutput;
        theAddress.mSelector = kAudioHardwareServiceDeviceProperty_VirtualMasterVolume;
        
        if(AudioObjectHasProperty(defaultDevID, &theAddress)){
		
            theError = AudioObjectGetPropertyData(defaultDevID, &theAddress, 0, NULL, &theSize, &theVolume);
            
            if(theError == noErr){

                returnValue.setDoubleValue(theVolume > 1.0 ? 1.0 : (theVolume < 0.0 ? 0.0 : theVolume));

            }
        }
    }
#else
    HRESULT hr;
    IMMDeviceEnumerator *pDevEnum;
    IMMDevice *pDev;
    IAudioEndpointVolume *pIaudEndPt;
    DWORD dwClsCtx = 0;
    float fVolume;
    
    hr = CoCreateInstance(CLSID_MMDeviceEnumerator, NULL, CLSCTX_ALL, IID_IMMDeviceEnumerator, (void**)&pDevEnum);

    if(hr == S_OK){
        hr = pDevEnum->GetDefaultAudioEndpoint(eRender, eConsole, &pDev);
        if(hr == S_OK){
            hr = pDev->Activate(iidAEV, dwClsCtx, NULL, (void**) &pIaudEndPt);
            if(hr == S_OK){
                hr = pIaudEndPt->GetMasterVolumeLevelScalar(&fVolume);
                if(hr == S_OK){
                    returnValue.setDoubleValue(fVolume);
                }
            }
            pDev->Release();
        }  
        pDevEnum->Release(); 
    }
#endif
    
	returnValue.setReturn(pResult);
}

#if VERSIONMAC
void AUDIO_SET_MUTE(UInt32 muted){

    AudioDeviceID				defaultDevID = kAudioObjectUnknown;
	AudioObjectPropertyAddress	theAddress;
	Boolean						canMute = YES;
	OSStatus					theError = noErr;
        
    defaultDevID = obtainDefaultOutputDevice();
    
	if(defaultDevID != kAudioObjectUnknown){
    
        theAddress.mElement = kAudioObjectPropertyElementMaster;
        theAddress.mScope = kAudioDevicePropertyScopeOutput;
        theAddress.mSelector = kAudioDevicePropertyMute;    
        
        if(AudioObjectHasProperty(defaultDevID, &theAddress)){
        
            theError = AudioObjectIsPropertySettable(defaultDevID, &theAddress, &canMute);
            
            if(theError == noErr && canMute){
            
                theError = AudioObjectSetPropertyData(defaultDevID, &theAddress, 0, NULL, sizeof(muted), &muted);

            }
        }
	}
}
#endif

#if VERSIONWIN
void AUDIO_SET_MUTE(BOOL bMute)
{
    HRESULT hr;
    IMMDeviceEnumerator *pDevEnum;
    IMMDevice *pDev;
    IAudioEndpointVolume *pIaudEndPt;
    DWORD dwClsCtx = 0;

    hr = CoCreateInstance(CLSID_MMDeviceEnumerator, NULL, CLSCTX_ALL, IID_IMMDeviceEnumerator, (void**)&pDevEnum);

    if(hr == S_OK){
        hr = pDevEnum->GetDefaultAudioEndpoint(eRender, eConsole, &pDev);
        if(hr == S_OK){
            hr = pDev->Activate(iidAEV, dwClsCtx, NULL, (void**) &pIaudEndPt);
            if(hr == S_OK){
                hr = pIaudEndPt->SetMute(bMute, NULL);
            }
            pDev->Release();
        }  
        pDevEnum->Release(); 
    }
}
#endif

void AUDIO_SET_MUTE(sLONG_PTR *pResult, PackagePtr pParams)
{
	C_LONGINT Param1;

	Param1.fromParamAtIndex(pParams, 1);

#if VERSIONMAC
    AUDIO_SET_MUTE(Param1.getIntValue() ? 1 : 0);
#else
    AUDIO_SET_MUTE(Param1.getIntValue() ? TRUE : FALSE);
#endif    
}

void AUDIO_Get_mute(sLONG_PTR *pResult, PackagePtr pParams)
{
	C_LONGINT returnValue;

#if VERSIONMAC
    AudioDeviceID				defaultDevID = kAudioObjectUnknown;
	UInt32						theSize = sizeof(UInt32);
	OSStatus					theError;
	UInt32						muted = 0;
	AudioObjectPropertyAddress	theAddress;
    
    defaultDevID = obtainDefaultOutputDevice();
    
	if(defaultDevID != kAudioObjectUnknown){

        theAddress.mElement = kAudioObjectPropertyElementMaster;    
        theAddress.mScope = kAudioDevicePropertyScopeOutput;
        theAddress.mSelector = kAudioDevicePropertyMute;
        
        if(AudioObjectHasProperty(defaultDevID, &theAddress)){
		
            theError = AudioObjectGetPropertyData(defaultDevID, &theAddress, 0, NULL, &theSize, &muted);
            
            if(theError == noErr){

                returnValue.setIntValue(muted ? 1 : 0);

            }
        }
    }
#else
    HRESULT hr;
    IMMDeviceEnumerator *pDevEnum;
    IMMDevice *pDev;
    IAudioEndpointVolume *pIaudEndPt;
    DWORD dwClsCtx = 0;
    BOOL bMute;
    
    hr = CoCreateInstance(CLSID_MMDeviceEnumerator, NULL, CLSCTX_ALL, IID_IMMDeviceEnumerator, (void**)&pDevEnum);

    if(hr == S_OK){
        hr = pDevEnum->GetDefaultAudioEndpoint(eRender, eConsole, &pDev);
        if(hr == S_OK){
            hr = pDev->Activate(iidAEV, dwClsCtx, NULL, (void**) &pIaudEndPt);
            if(hr == S_OK){
                hr = pIaudEndPt->GetMute(&bMute);
                if(hr == S_OK){
                    returnValue.setIntValue(bMute ? 1 : 0);
                }
            }
            pDev->Release();
        }  
        pDevEnum->Release(); 
    }
#endif

	returnValue.setReturn(pResult);
}